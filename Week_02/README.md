# 学习笔记
### N叉树的后序遍历
* 解决思路： *
将树的各个节点值和当前节点依次存入两个数组中，循环每次弹出数组的最后一个节点，在有子树的情况下再将子树的值和节点存入数组中，最后倒序输出数组。当然也可以用递归法解决。
### N叉树的前序遍历
* 解决思路： * 跟后序遍历类似，只不过存入子树的时候使用倒序的的方法，输出结果的时候正常输出。
### 二叉树的中序遍历
* 解决思路： * 二叉树中序遍历：左根右。从最左侧开始存入子树的值，当到底后反弹到上层父亲节点，再转入右侧子节点。
### 二叉树的前序遍历
* 解决思路： * 二叉树前序遍历：根左右，利用一个数组存结果，一个栈存走过的路径，到底后反弹回上一个节点。
### N叉树的层序遍历
* 解决思路： * 对每一层的结果单独遍历和保存，最后汇总到结果数组中。
### 丑数
* 解决思路： * 虽然本题是在堆里的实战题目，但我感觉利用动态规划更容易解决一些。动态规划专门用来解决一些分情况讨论的前后相关的迭代题。本题通过分析可以发现，丑数只能通过上一个丑数乘以2、3、5来得到，按升序排列的话，丑数就要是上一个丑数乘以2、3、5后最小的一个数。
### 前K个高频元素
* 解决思路： * 利用哈希表和大顶堆解决，首先用哈希表记录每个元素出现的次数和对应的元素，然后将他们存入大顶堆，最后返回大顶堆最顶的K个元素即可。
### 二叉树的最近公共祖先
* 解决思路： * 递归，寻找左右两个节点的祖先是否相同。
### 从前序和中序遍历构造二叉树
* 解决思路： * 利用前序可得到二叉树的根，利用中序可以得到二叉树根的下标，中序根左侧是左子树的中序，右侧是右子树的中序，而前序中从根开始到根下标之前的部分是左子树前序，其余部分是右子树前序。
### 组合
* 解决思路： * 回溯算法+剪枝，每次选择完一个数后，接下来的选择就要把当前的数排除。
